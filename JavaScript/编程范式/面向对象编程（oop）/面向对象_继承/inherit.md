### 对象继承关系如何实现？(\_\_proto\_\_)



### 类式继承的相关阐述

1.原型链继承
    实现的本质：重写原型对象，代之以一个新类型的实例。  
    问题一：包含引用类型值的原型属性会被所有实列共享，所以我们要在构造函数中，而不是在原型对象中定义属性。
    问题二：在创建子类型的实例时，不能向超类（父类）型的构造函数中传递参数。换句话说，没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。

2.借用构造函数继承
    基本思想：在子类型构造函数的内部调用超类型构造函数，通过使用apply()和call()方法在新创建的对象上执行构造函数
    优势：相对于原型链而言，可以在子类型构造函数中向超类型构造函数传递参数
    缺点：无法避免方法都在构造函数中定义，无法实现函数复用。

3.组合继承
    原理：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。
    问题：无论什么情况下，都会调用两次父类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。子类型最终会包含父类型对象的全部实例属性，但不得不在调用子类型构造函数时重写这些属性。

4.寄生组合继承
    目的：解决组合继承中的两次调用问题。
    核心：把原型继承的形式变成了寄生式继承。（不必为了指定子类型的原型而调用父类型的构造函数，从而寄生式继承只继承了父类型的原型属性，而父类型的实例属性是通过借用构造函数的方式来得到的）

5.ES6中的class
​    

6.拷贝继承
    思想：把父对象的所有属性和方法，拷贝到子对象中。

7.非构造函数继承
    原理： 利用中间函数Foo将子类的prototype属性设置为父类